"use strict";

const {
    queryHandler, getPFkeys
} = require('../mysql/db');
const pluralize = require('pluralize');
const { exec } = require("child_process");


const modelName = (tableName) => {
    let parts = [];
    tableName.split("_").forEach((text) => {
        parts.push(pluralize.singular(text[0].toUpperCase() + text.slice(1)));
    })
    return parts.join('');
}

const tableFromCol = (col) => {
    return pluralize.plural(col.toLowerCase());   
}


const dtype = (mytype) => {
    const typeExtract = /(\w+) ?(\((\d*\,?\d+?)\))?/.exec(mytype);
    let colType = (typeExtract[1]) ? typeExtract[1] : "";
    let colSize = (typeExtract[3]) ? typeExtract[3] : "";
    return [colType, colSize];
}


const getDataType = (col) => {
    let [xtype, xsize] = dtype(col.Type);
    
    switch(xtype){
        case "char":
            return `STRING`;
            break;
        case "varchar":
            return `STRING`;
            break;
        case "tinytext":
            return `TEXT.TINY`;
            break;
        case "text":
            return `TEXT`;
            break;
        case "blob":
            return `STRING.BINARY`
            break;
        case "mediumtext":
            return `STRING`;
            break;
        case "longtext":
            return `TEXT`;
            break;
        case "longblob":
            return `STRING.BINARY`;
            break;
        case "tinyint":
            return `INTEGER`;
            break;
        case "smallint":
            return `INTEGER`;
            break;
        case "mediumint":
            return `INTEGER`;
            break;
        case "int":
            return `INTEGER`;
            break;
        case "bigint":
            return `BIGINT`;
            break;
        case "float":
            return `FLOAT`;
            break;
        case "double":
            return `DOUBLE`;
            break;
        case "decimal":
            return `DECIMAL`;
        case "date":
            return `DATEONLY`;
            break;
        case "datetime":
            return `DATE`;
            break;
        case "timestamp":
            return `DATE`;
            break;
        case "enum":
            return `ENUM`;
            break;
    }
}

module.exports.makeModel = (tableName) => {    
    return queryHandler(`DESC ${tableName}`)
        .then((result) => {
            const model = modelName(tableName);
            let associations = [];
            let refs = [];
            let nullables = [];
            let modelcmd = "sequelize model:generate --name "+model+" --attributes ";
            let icounter = 0;
            result.forEach((col) => {
                if (col.Field == "id" || col.Field == "deletedAt" || col.Field == "createdAt" || col.Field == "updatedAt")
                {
                    //donothing;
                } else {
                    let dtype = getDataType(col);
                    const nulled = (col.Null === "NO") ? 0 : 1;
                    if (icounter < result.length) {
                        modelcmd += col.Field+":"+dtype+",";
                    } else {
                        modelcmd += col.Field+":"+dtype;
                    }
                }
                icounter++;
            });
            modelcmd+="#";
            console.log(modelcmd,"\n\n\n\n");
            let ncmd = modelcmd.replace(",#","");
            exec(ncmd, (error, stdout, stderr) => {
                if (error) {
                    console.log(`error: ${error.message}`);
                    return;
                }
                if (stderr) {
                    console.log(`stderr: ${stderr}`);
                    return;
                }
                console.log(`stdout: ${stdout}`);
            });       
            
            const dorelations = (data) => {
                let ptab;
                data.forEach((row) => {
                    ptab = row.table_name;
                    let tableName = pluralize.singular(row.referenced_table_name);
                    let fmodel = modelName(tableName);
                    //let rel = `const ${fmodel} = require('../models/${tableName}');\n`;
                    //let assoc = `${model}.belongsTo(${fmodel}, {foreignKey:'${row.column_name}'});\n`;
                    if(!relate.includes(rel)){
                        relate.push(rel);
                        associations.push(assoc);
                        //let rfo = {`${row.column_name}`:`${row.referenced_table_name}`};
                        refs[row.column_name] = row.referenced_table_name;
                    }
                });
                return relate.join('');
            }

            const relations = async (tableName) => {

                const res = await getPFkeys(tableName); 
                const data = await res;

                dorelations(data);
                goahead();
            };
        })
        .catch((error) => {
            throw error;
        })
}