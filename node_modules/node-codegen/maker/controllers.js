const pluralize = require('pluralize');
const { queryHandler,getPFkeys, notEmpty } = require('../mysql/db');

const capitalizeFirstLetter = (word) => {
    return word.charAt(0).toUpperCase() + word.substring(1);
}

const makeModelName = (tableName) => {
    const pluralName = pluralize.singular(tableName);
    return pluralName.charAt(0).toUpperCase() + pluralName.substring(1);
}

module.exports.makeController = (tableName) => {
    const modelName = makeModelName(tableName);
    return queryHandler(`DESC ${tableName}`).then((result) => {
        const tableColumns = [];
        const forKeys = [];
        const forInKeyVal  = [];
        const fileColumns = [];
        result.forEach((col, pos) => {
            if (col['Key'] === "MUL") {
                forInKeyVal.push(col.Field);
            }
            tableColumns.push(col.Field);

            if ((/picture$/.test(col.Field)) || (/Picture$/.test(col.Field))|| (/video$/.test(col.Field)) || (/Video$/.test(col.Field))
                || (/audio$/.test(col.Field))|| (/Audio$/.test(col.Field))  || (col.Field.toLowerCase() === "mediaurl") 
                || (/file$/.test(col.Field)) || (/File$/.test(col.Field))) {
                fileColumns.push(col.Field);
            }
        });

        return getPFkeys(tableName, forInKeyVal.join("','"), "", "").then((foreignKeys) => {
            let file_includes = "";
            const toIncludeArr = [];
            let modelIncludeString = "";
            if (notEmpty(foreignKeys, Array)) {
                foreignKeys.forEach((item) => {
                    const toInclude = pluralize.singular(item['referenced_table_name']);
                    const toIncludeVar = makeModelName(item['referenced_table_name']);
                    let column_name = item['column_name'];

                    if (/id$/i.exec(column_name)) column_name = column_name.replace(/id$/i, "");
                    column_name = capitalizeFirstLetter(column_name);
                    
                    if (!toIncludeArr.includes(toInclude)) {
                        file_includes += `const ${toIncludeVar} = require(".././models").${toInclude};\n`;
                        modelIncludeString += `{ model: ${toIncludeVar}, attributes: ['id'], as: '${column_name}' },`;
                        toIncludeArr.push(toInclude);
                    }
                });
            }

            let makeString = "";
            makeString += makeCreate(modelName, tableColumns, file_includes, tableName);
            makeString += makeRead(modelName, tableColumns, foreignKeys, tableName);
            makeString += makeShow(modelName, tableColumns, modelIncludeString);
            makeString += makeUpdate(modelName, tableColumns);
            makeString += makeRemove(modelName, tableColumns, modelIncludeString, foreignKeys);
            return makeString;
        });
    }).catch((error) => {
        throw error;
    });
};


const makeShow = (modelName, tableColumns, modelIncludeString) => {
    let writeString = "";
    writeString += `\nmodule.exports.show = (request, response, next) => {\n`;
    writeString += `    if ((request.body.currUserRole !== '1') && (request.body.currUserRole !== '0') && (restrictAccess.show)) {\n`;
    writeString += `        return response.status(200).json({\n`;
    writeString += `            "message":"Access denied, Admin Only"\n`;
    writeString += `        });\n`;
    writeString += `    }\n`;

    writeString += `    fetchRecs(request, response).then((result) => {\n`;
    writeString += `        return response.status(200).json(result);\n`;
    writeString += `    }).catch((error) => {\n`;
    writeString += `        Utils.logError(error);\n`;
    writeString += `        return response.status(500).json({ "message":error});\n`;
    writeString += `    });\n`;
    writeString += `};\n`;
    return writeString;
}


const makeUpdate = (modelName) => {
    let writeString = "";
    writeString += `\n\nmodule.exports.update = (request, response, next) => {\n`;
    writeString += `    if ((request.body.currUserRole !== '1') && (restrictAccess.update)) {\n`;
    writeString += `        return response.status(200).json({\n`;
    writeString += `            "message":"Access denied, Admin Only"\n`;
    writeString += `        });\n`;
    writeString += `    }\n`;

    writeString += `    const { currUserId, currUserEmail, currUserRole, requestBody } = Utils.resolveCurrUserInfo(request.body);\n`;
    writeString += `    ${modelName}.findAll({\n`;
    writeString += `        where : { id: request.params.id },\n`;
    writeString += `        attributes: ['id']\n`;
    writeString += `    }).then((result) => {\n`;
    writeString += `        if (Utils.notEmptyArray(result)) {\n`;
    writeString += `            ${modelName}.update({ ...requestBody, modifiedBy:currUserId }, {\n`;
    writeString += `                where: {id: request.params.id }\n`;
    writeString += `            })\n`;
    writeString += `            .then((update) => {\n`;
    writeString += `                return response.status(200).json({\n`;
    writeString += `                    "status": true,\n`;
    writeString += `                    "message": "success",\n`;
    writeString += `                    "data": update\n`;
    writeString += `                });\n`;
    writeString += `            })\n`;
    writeString += `            .catch((error) => {\n`;
    writeString += `                Utils.logError(error);\n`;
    writeString += `                return response.status(500).json({\n`;
    writeString += `                    "status": false,\n`;
    writeString += `                    "message": "Could Not Update ${modelName} Details",\n`;
    writeString += `                    "data": []\n`;
    writeString += `                });\n`;
    writeString += `            });\n`;
    writeString += `        } else {\n`;
    writeString += `            return response.status(500).json({\n`;
    writeString += `                "status": false,\n`;
    writeString += `                "message": "${modelName} record not found!",\n`;
    writeString += `                "data": []\n`;
    writeString += `            });\n`;
    writeString += `        }\n`;
    writeString += `    })\n`;
    writeString += `    .catch((error) => {\n`;
    writeString += `        Utils.logError(error);\n`;
    writeString += `        return response.status(500).json({\n`;
    writeString += `            "status": false,\n`;
    writeString += `            "message": "${modelName} record not resolved!",\n`;
    writeString += `            "data": []\n`;
    writeString += `        });\n`;
    writeString += `    });\n`;
    writeString += `};\n`;
    return writeString;  
};


const makeRemove = (modelName, tableColumns, modelIncludeString, foreignKeys) => {
    readString = "";
    readString += `\n\nmodule.exports.remove = (request, response, next) => {\n`;
    readString += `    if ((request.body.currUserRole !== '1') && (restrictAccess.remove)) {\n`;
    readString += `        return response.status(200).json({\n`;
    readString += `            "message":"Access denied, Admin Only"\n`;
    readString += `        });\n`;
    readString += `    }\n`;

    readString += `    ${modelName}.findAll({\n`;
    readString += `        attributes: ['id'],\n`;
    readString += `        where : { id: request.params.id }\n`;
    readString += `    }).then((result) => {\n`;
    readString += `        if (Utils.notEmptyArray(result)) {\n`;
    readString += `            ${modelName}.destroy({\n`;
    readString += `                where: { id: request.params.id }\n`;
    readString += `            })\n`;
    readString += `            .then((status) => {\n`;
    readString += `                return response.status(200).json({\n`;
    readString += `                    "status": status,\n`;
    readString += `                    "message": "${modelName} Record Deleted successfully!",\n`;
    readString += `                    "data": []\n`;
    readString += `                });\n`;
    readString += `            }).catch((error) => {\n`;
    readString += `                Utils.logError(error);\n`;
    readString += `                return response.status(500).json({\n`;
    readString += `                    "status": false,\n`;
    readString += `                    "message": "${modelName} Record Deletion failed!",\n`;
    readString += `                    "data": []\n`;
    readString += `                });\n`;
    readString += `            });\n`;
    readString += `        } else {\n`;
    readString += `            return response.status(500).json({\n`;
    readString += `                "status": false,\n`;
    readString += `                "message":"${modelName} record not found!",\n`;
    readString += `                "data": []\n`;
    readString += `            });\n`;
    readString += `        }\n`;
    readString += `    })\n`;
    readString += `    .catch((error) => {\n`;
    readString += `        Utils.logError(error);\n`;
    readString += `        return response.status(500).json({\n`;
    readString += `            "status": false,\n`;
    readString += `            "message":"${modelName} record not resolved!",\n`;
    readString += `            "data": []\n`;
    readString += `        });\n`;
    readString += `    });\n`;
    readString += `};\n\n\n`;

    readString += `const fetchRecs = (request, response) => {\n`;
    readString += `    const {currUserId, currUserEmail, currUserRole} = Utils.reAuth(request.headers.authorization);\n`;    
    readString += `    let inparam = {\n`;
    readString += `        attributes: [\n`;
    readString += `            '${tableColumns.join("', '")}'\n`;
    readString += `            //,[Sequelize.literal(\`(SELECT Table.columname FROM Table WHERE Modulename.createdBy=Table.id\`), 'valueName'],\n`;
    readString += `        ],\n`;
    readString += `        include: [], order: [['createdAt', 'DESC']]\n`;
    readString += `    };\n\n`;


    let forKeysArr = [];
    readString += `    inparam.where = {};\n`;
    readString += `    if (request.params.id) inparam.where.id = request.params.id;\n`;
    if (foreignKeys.length) {
        foreignKeys.forEach((item) => {
            if (!forKeysArr.includes(item['column_name'])) {
                let rqPath        = item['referenced_table_name'].toLowerCase();
                let column_name   = item['column_name'];
                readString += `    if (request.query.${column_name}) inparam.where.${column_name} = request.query.${column_name};\n`;
                forKeysArr.push(item['column_name']);
            }
        });
        readString += `\n`;
    }
    readString += `    if (request.query.fieldTo) {\n`;
    readString += `        let fieldToSplit = request.query.fieldTo.split(",");\n`;
    readString += `        if (fieldToSplit.length) inparam.attributes = fieldToSplit.map(item => item.trim());\n`;
    readString += `    }\n\n`;


    readString += `    inparam.distinct = true;\n`;
    readString += `    inparam.limit = (request.query.limit) ? +request.query.limit : 20;\n`;
    readString += `    inparam.offset = (request.query.offset) ? +request.query.offset : 0;\n\n`;

    if (modelIncludeString !== "") {
        let modelStringSplit = modelIncludeString.split("},");
        modelStringSplit.forEach((item, pos) => {
            if (item !== "") {
                readString += `    inparam.include.push(${item}});\n`;
                //readString += `        ${item}}\n`;
                //readString += `    );\n\n`;
            }
        });
        readString += `\n`;
    }

    readString += `    //findAll\n`;
    readString += `    return ${modelName}.findAndCountAll(inparam).then((result) => {\n`;
    readString += `        return result;\n`;
    readString += `    }).catch((error) => {\n`;
    readString += `        return error;\n`;
    readString += `    });\n`;
    readString += `};`;
    return readString;
};


const makeCreate = (modelName, tableColumns, file_includes, tableName) => {
    readString = "";
    readString += `const Utils = require("../utilities/utils");\n`;
    if (tableName.toUpperCase() === "USERS") {
        readString += `const bcrypt = require('bcrypt');\n`;
        readString += `const jwt = require('jsonwebtoken');\n`;
    }
    readString += `const ${modelName} = require(".././models").${pluralize.singular(tableName)};\n`;
    readString += `${file_includes}\n\n`;

    readString += `const restrictAccess = {\n`;
    readString += `    create: false,\n`;
    readString += `    index: false,\n`;
    readString += `    show: false,\n`;
    readString += `    update: false,\n`;
    readString += `    remove: false\n`;
    readString += `};\n\n\n`;

    readString += `module.exports.create = (request, response, next) => {\n`;
    if (tableName.toUpperCase() === "USERS") {
        readString += `    if (!request.body.userRole) request.body.userRole = 0;\n`;
        readString += `    bcrypt.hash(request.body.password, 10).then((hash) => {\n`;
        readString += `        User.create({...request.body, password:hash}).then((user) => {\n`;
        readString += `            const userId = user.dataValues.id;\n`;
        readString += `            const payLoadParam = userId + "!~+=" + user.dataValues.email + "!~+=" + user.dataValues.userRole;\n`;
        readString += `            const token = jwt.sign({userId:payLoadParam}, 'RANDOM_TOKEN_SECRET', {expiresIn:'24h'});\n`;
        readString += `            return response.status(201).json({\n`;
        readString += `                "status": true,\n`;
        readString += `                "data":{ "token":token, "userId":userId, "message": "success", "userRole": user.dataValues.userRole }\n`;
        readString += `            });\n`;
        readString += `        })\n`;
        readString += `        .catch((error) => {\n`;
        readString += `            return response.status(500).json({ "message": "User sign failed" });\n`;
        readString += `        });\n`;
        readString += `    }).catch((error) => {\n`;
        readString += `        //console.log(error);\n`;
        readString += `        return response.status(500).json({ "message": "User sign failed" });\n`;
        readString += `    });\n`;
    } else {
        readString += `    if ((request.body.currUserRole !== '1') && (restrictAccess.create)) {\n`;
        readString += `        return response.status(200).json({\n`;
        readString += `            "message":"Access denied, Admin Only"\n`;
        readString += `        });\n`;
        readString += `    }\n\n`;
    
        readString += `    const {currUserId, currUserEmail, currUserRole, requestBody} = Utils.resolveCurrUserInfo(request.body);\n`;
        readString += `    //User the table structure to Generate the right validation for Inputs\n\n`;
    
        readString += `    const paramObj = {...requestBody};\n`;
        readString += `    if (currUserId) paramObj.createdBy = currUserId;\n`;
        readString += `    ${modelName}.create(paramObj)\n`;
        readString += `    .then((result) => {\n`;
        readString += `        return response.status(200).json({\n`;
        readString += `            "status": true,\n`;
        readString += `            "message": "success",\n`;
        readString += `            "data": result\n`;
        readString += `        });\n`;
        readString += `    }).catch((error) => {\n`;
        readString += `        Utils.logError(error);\n`;
        readString += `        return response.status(500).json({\n`;
        readString += `            "status": false,\n`;
        readString += `            "message": "Record not saved",\n`;
        readString += `            "data": []\n`;
        readString += `        });\n`;
        readString += `    });\n`;
    }
    readString += `};\n\n`;
    return readString;
};


const makeRead = (modelName, tableColumns, forKeys, tableName) => {
    let readString = "";
    readString += `\nmodule.exports.index = (request, response, next) => {\n`;
    readString += `    if ((request.body.currUserRole !== '1') && (restrictAccess.index)) {\n`;
    readString += `        return response.status(200).json({\n`;
    readString += `            "message":"Access denied, Admin Only"\n`;
    readString += `        });\n`;
    readString += `    }\n`;
    readString += `    fetchRecs(request).then((result) => {\n`;
    readString += `        return response.status(200).json(result);\n`;
    readString += `    }).catch((error) => {\n`;
    readString += `        Utils.logError(error);\n`;
    readString += `        return response.status(500).json({ "message":error});\n`;
    readString += `    });\n`;
    readString += `};\n\n\n`;

    if (tableName.toUpperCase() === "USERS") {
        readString += `module.exports.getUser = (request, response, next) => {\n`;
        readString += `    User.findAll({\n`; //
        readString += `        attributes: ['${tableColumns.join("', '")}'],\n`;
        readString += `        where : { email: request.body.email }\n`;
        readString += `    })\n`;
        readString += `    .then((user) => {\n`;
        readString += `        bcrypt.compare(request.body.password, user[0].dataValues.password)\n`;
        readString += `        .then((valid) => {\n`;
        readString += `            if (!valid) {\n`;
        readString += `                return response.status(401).json({"message": "Incorrect Password"});\n`;
        readString += `            }\n`;
        readString += `            const userId = user[0].dataValues.id;\n`;
        readString += `            const payLoadParam = userId + "!~+=" + user[0].dataValues.email + "!~+=" + user[0].dataValues.userRole;\n`;
        readString += `            const token = jwt.sign({userId:payLoadParam}, 'RANDOM_TOKEN_SECRET', {expiresIn:'24h'});\n`;
        readString += `            return response.status(200).json({\n`;
        readString += `                "status": true, "data":{ "token":token, "userId":userId, "message": "success", "userRole":user[0].dataValues.userRole || 0 }\n`;
        readString += `            });\n`;
        readString += `        })\n`;
        readString += `        .catch((error) => {\n`;
        readString += `            return response.status(500).json({ "message": "User cannot be Authenticated!" });\n`;
        readString += `        });\n`;
        readString += `    })\n`;
        readString += `    .catch((error) => {\n`;
        readString += `        return response.status(500).json({ "message" : "User Not Found!" });\n`;
        readString += `    });\n`;
        readString += `};\n\n\n`;
    
        readString += `module.exports.checkDsUser = (request, response, next) => {\n`;
        readString += `    const currUserId = request.body.currUserId;\n`;
        readString += `    const currUserEmail = request.body.currUserEmail;\n`;
        readString += `    const currUserRole = request.body.currUserRole;\n`;
        readString += `    User.findAll({\n`;
        readString += `        attributes: ['names', 'userRole','id'],\n`;
        readString += `        where: { id: currUserId, email:currUserEmail }\n`;
        readString += `    })\n`;
        readString += `    .then((user) => {\n`;
        readString += `        const rVals =  user[0].dataValues;\n`;
        readString += `        if ((Object.keys(user).length > 0) && (user.constructor === Array)) {\n`;      
        readString += `            return response.status(200).json({\n`;
        readString += `                "userName": rVals.names,\n`;
        readString += `                "isAdmin": rVals.userRole ? true : false,\n`;
        readString += `                "isValid": true,\n`;
        readString += `                "uId": rVals.id\n`;
        readString += `            });\n`;
        readString += `        } else {\n`;
        readString += `            return response.status(200).json({\n`;
        readString += `                "userName": '',\n`;
        readString += `                "isAdmin": false,\n`;
        readString += `                "isValid": false,\n`;
        readString += `                "uId": ""\n`;
        readString += `            });\n`;
        readString += `        }\n`;
        readString += `    }).catch((error) => {\n`;
        readString += `        return response.status(500).json({ "message":"Could not resolve User Details"});\n`;
        readString += `    });\n`;
        readString += `};\n\n\n`;  
        
        readString += `module.exports.initUser = (request, response, next) => {\n`; 
        readString += `    const currUserId = request.body.currUserId;\n`; 
        readString += `    const currUserEmail = request.body.currUserEmail;\n`; 
        readString += `    const currUserRole = request.body.currUserRole;\n`; 

        readString += `    let isValid = false;\n`; 
        readString += `    if (currUserRole === '1') isValid = true;\n`; 
        readString += `    return response.status(201).json({\n`; 
        readString += `        "status": isValid\n`; 
        readString += `    });\n`; 
        readString += `};\n\n\n`;
        

        readString += `module.exports.facebooklogin = (request, response, next) => {\n`;
        readString += `    //TO DO\n`;
        readString += `};\n\n\n`;


        readString += `module.exports.googlelogin = (request, response, next) => {\n`;
        readString += `    //TO DO\n`;
        readString += `};\n\n\n`;
        
        readString += `module.exports.pwdreset = (request, response, next) => {\n`; 
        readString += `    //TO DO\n`;
        //readString += `    const currUserId = request.body.currUserId;\n`; 
        //readString += `    const currUserEmail = request.body.currUserEmail;\n`; 
        //readString += `    const currUserRole = request.body.currUserRole;\n`; 

        //readString += `    let isValid = false;\n`; 
        //readString += `    if (currUserRole === '1') isValid = true;\n`; 
        //readString += `    return response.status(201).json({\n`; 
        //readString += `        "status": isValid\n`; 
        //readString += `    });\n`; 
        readString += `};\n\n`;

    }

    return readString; //pwdreset
};